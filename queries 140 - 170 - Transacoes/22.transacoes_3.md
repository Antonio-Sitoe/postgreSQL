# ✅ **Mais 10 Exercícios Avançados de Transações (21–30)**

---

## **21. Teste de LOST UPDATE com duas transações**

**Objetivo:** Observar o problema da _atualização perdida_ sem bloqueios adequados.
**Tarefa:**

1. Na **Transação A**, selecione o saldo da conta 1.
2. Na **Transação B**, selecione o mesmo saldo.
3. Cada transação soma +100 ao saldo lido.
4. Commit nas duas.
   **Pergunta:** O banco preserva os dois incrementos? Ou um deles se perde?

---

## **22. Resolver LOST UPDATE usando SELECT FOR UPDATE**

**Objetivo:** Resolver o problema anterior com locking explícito.
**Tarefa:**

1. Na **Transação A**, selecione `saldo` com:

   ```sql
   SELECT saldo FROM conta WHERE id = 1 FOR UPDATE;
   ```

2. Só depois abra a **Transação B**.
3. A B deve aguardar A terminar.
4. Atualize saldo em ambas e commit.
   **Pergunta:** Ambas as atualizações foram aplicadas corretamente?

---

## **23. Simular DIRTY READs com READ UNCOMMITTED**

**Objetivo:** Verificar leitura de dados não confirmados.
**Tarefa:**

1. Transação A atualiza o nome de um cliente, mas **não dá commit**.
2. Transação B usa nível:

   ```sql
   SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
   ```

   e lê os dados.

3. Transação A dá rollback.
   **Pergunta:** B viu o valor que nunca deveria existir?

---

## **24. Evitar DIRTY READs com READ COMMITTED**

**Objetivo:** Garantir que transações só leem dados confirmados.
**Tarefa:**

1. Repita o exercício 23, mas agora usando:

   ```sql
   SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
   ```

2. Execute A (sem commit) e B tentando ler.
   **Pergunta:** A leitura de B retornou o dado antigo ou o “sujo”?

---

## **25. Simular NON-REPEATABLE READ**

**Objetivo:** Demonstrar quando o mesmo SELECT retorna valores diferentes.
**Tarefa:**

1. Transação A lê dados da conta 1.
2. Transação B altera o saldo e dá commit.
3. Transação A lê novamente.
   **Pergunta:** Os dois SELECTs retornam valores diferentes?

---

## **26. Resolver NON-REPEATABLE READ com REPEATABLE READ**

**Objetivo:** Utilizar isolamento para estabilizar leituras.
**Tarefa:**

1. Transação A define:

   ```sql
   SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
   ```

2. A lê a conta 1.
3. B altera e confirma.
4. A lê novamente.
   **Pergunta:** A transação A viu a mudança feita por B?

---

## **27. Testar PHANTOM READ (inserção fantasma)**

**Objetivo:** Observar quando novos registros aparecem durante a transação.
**Tarefa:**

1. Transação A lê todos os clientes com nota > 3.
2. Transação B insere um novo cliente com nota > 3 e confirma.
3. Transação A lê novamente.
   **Pergunta:** O novo cliente aparece?

---

## **28. Evitar PHANTOM READ usando SERIALIZABLE**

**Objetivo:** Impedir inserções fantasma.
**Tarefa:**

1. Transação A define:

   ```sql
   SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
   ```

2. A faz o SELECT dos clientes VIP.
3. B tenta inserir um novo cliente VIP.
   **Resultado esperado:** B deve travar até A finalizar.

---

## **29. Testar Deadlock com duas transações cruzadas**

**Objetivo:** Criar deadlock intencional.
**Tarefa:**

1. Transação A bloqueia cliente 1 usando `FOR UPDATE`.
2. Transação B bloqueia cliente 2.
3. A tenta atualizar cliente 2.
4. B tenta atualizar cliente 1.
   **Pergunta:** Qual transação o banco força a abortar?

---

## **30. Resolver deadlock reorganizando operações**

**Objetivo:** Garantir ordem consistente de atualização.
**Tarefa:**

1. Execute novamente o exercício 29, mas agora ambas as transações atualizam os registros **na mesma ordem** (cliente 1 → cliente 2).
2. Verifique se o deadlock desaparece.
   **Pergunta:** O banco executou ambas sem conflito?

---
